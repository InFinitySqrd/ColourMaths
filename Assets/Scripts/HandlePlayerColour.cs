using UnityEngine;
using System.Collections;

public class HandlePlayerColour : MonoBehaviour {
	// Declare variables
	// Get a reference to the target colour
	[SerializeField] Material playerColour;
	
	// Get a refernece to the goal colour
	[SerializeField] RandomColourAssignment goalColour;
	
	// Get a reference to the script that controls the success animation
	[SerializeField] SuccessAnimation successAnim;	

	// Determine the rate at which the colour will lerp to its target
	[SerializeField] float colourLerpSpeed = 1.0f;
	
	// Create an array to store the current colour generated by the player
	private int[] currentColour; 

	// Record the current colour the player has entered, so the material can lerp to it over time
	private Color targetColour, presentColour;
	
	// Keep a tally of the number of colours entered by the player
	private int numColoursEntered = 0;

	// Declare a variable to track the progress of a colour lerp
	private float lerpTimer = 0.0f;

	// Initialise all required values
	void Awake () {
		// Set the initial colour of the player cube
		playerColour.SetColor("_Color", new Color(0,0,0));
		presentColour = playerColour.color;
		targetColour = presentColour;
		
		// Initialise the array of colours the player will be using
		currentColour = new int[3];
		
		// Set all the starting colour values to 0
		for (int i = 0; i < currentColour.Length; i++) {
			currentColour[i] = 0;
		}
	}

	// Update the colour of the player's selection each frame, where appropriate
	void Update () {
		// Check to see if there is a target colour to lerp to
		if (targetColour != null && playerColour.color != targetColour) {
			// Declare a variable to hold the displayed colour
			Color currentColour;

			// Calculate the colour to be displayed
			currentColour = Color.Lerp(presentColour, targetColour, lerpTimer * Time.deltaTime);
			lerpTimer = lerpTimer + colourLerpSpeed;

			// Set the player's colour to the Lerping value
			playerColour.SetColor("_Color", currentColour);
		} else {
			lerpTimer = 0.0f;
		}
	}
		
	public void UpdatePlayerColour() {
		// Determine the greates value in the colour list
		int maxColour = currentColour[0];
		
		for (int i = 1; i < currentColour.Length; i++) {
			if (currentColour[i] > maxColour) {
				maxColour = currentColour[i];
			}
		}
		
		// Calculate each colour as a percentage of white
		float r = (255.0f / maxColour) * currentColour[0];
		float g = (255.0f / maxColour) * currentColour[1];
		float b = (255.0f / maxColour) * currentColour[2];
		
		// Assign the colour to the cube (Observing the / by 255 requirement)		
		if (lerpTimer == 0.0f) {
			presentColour = targetColour;
		} else {
			presentColour = playerColour.color;
			lerpTimer = 0.0f;
		}
		targetColour = new Color(r / 255.0f, g / 255.0f, b / 255.0f);
		
		// Check to see if the player has won
		CheckWinCondition();
	}

	// Check to see if the player has created the correct colour
	private void CheckWinCondition() {
		// Get the goal colour array
		int[] goal = goalColour.GetTargetColour();
		
		// Create a boolean to see if the player has won
		bool winner = true;
		
		// Create and set an integer to hold the target ration for the comparison
		float ratio = 0;
		
		if (currentColour[0] != 0) {
			ratio = ((float)goal[0] / (float)currentColour[0]);
		} else if (currentColour[1] != 0) {
			ratio = ((float)goal[1] / (float)currentColour[1]);
		} else if (currentColour[2] != 0) {
			ratio = ((float)goal[2] / (float)currentColour[2]);
		}
		
		// Check if each colour matches the goal
		for (int i = 0; i < goal.Length; i++) {
			// Multiply the current colour by the target ratio, to see if the user has achieved the correct colour
			if ((currentColour[i] * ratio) != goal[i]) {
				winner = false;
			}
		}
		
		if (winner) {
			HandleWinning();
		}
	}
	
	private void HandleWinning() {
		// Increase the player's score
		PlayerPrefs.SetInt("score", PlayerPrefs.GetInt("score") + 1);
		
		// Play the success animation
		successAnim.SetUpAnimation();
		
		// Create a new puzzle
		goalColour.CreateColour();
	}
	
	public void ClearPlayerColour() {
		// Clear the current colour array and start from scratch
		for (int i = 0; i < currentColour.Length; i++) {
			currentColour[i] = 0;
		}
		
		// Set the number of colours entered by the player to 0
		numColoursEntered = 0;
		
		// Assign the new colour to the player
		targetColour = new Color(0,0,0);
	}

	public int GetNumColoursEntered() {
		return numColoursEntered;
	}

	public void SetNumColours(int value) {
		numColoursEntered = value;
	}

	public void IncrementCurrentColour(int index) {
		currentColour[index]++;
	}

	public int[] GetPlayerColour() {
		return currentColour;
	}

	public Color GetTargetColour() {
		return targetColour;
	}
}
